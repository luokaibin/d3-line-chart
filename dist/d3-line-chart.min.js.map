{"version":3,"file":"d3-line-chart.min.js","sources":["../src/types.ts","../src/utils.ts","../src/d3-line-chart.ts"],"sourcesContent":["// 折线图配置接口\nexport interface LineChartConfig {\n  lineColor?: string;        // 折线颜色\n  showShadow?: boolean;      // 是否显示阴影\n  gridColor?: string;        // 网格线颜色\n  enableAnimation?: boolean; // 是否启用动画\n  animationDuration?: number; // 动画时长\n  axisTextColor?: string;    // 坐标轴文本颜色\n  axisTextSize?: string;     // 坐标轴文本字体大小\n  curveType?: 'linear' | 'curve'; // 折线类型：直线或曲线\n  tickCount?: number;        // Y轴刻度数量\n  margin?: {                 // 图表边距\n    top?: number;            // 上边距\n    right?: number;          // 右边距\n    bottom?: number;         // 下边距\n    left?: number;           // 左边距\n  };\n}\n\n// 数据点接口\nexport interface DataPoint {\n  x: number;\n  y: number;\n}\n\n// 关键点接口\nexport interface KeyPoint extends DataPoint {\n  render: string; // 关键点的渲染HTML\n}\n\n// 关键刻度点接口\nexport interface KeyTick {\n  x: number;\n  label: string;\n}\n\n// 默认配置\nexport const DEFAULT_CONFIG: LineChartConfig = {\n  lineColor: '#3498db',\n  showShadow: true,\n  gridColor: '#e0e0e0',\n  enableAnimation: true,\n  animationDuration: 1000,\n  axisTextColor: '#333333',\n  axisTextSize: '12px',\n  curveType: 'linear',\n  tickCount: 5,\n  margin: {\n    top: 20,\n    right: 30,\n    bottom: 40,\n    left: 50\n  }\n};\n","import { DataPoint } from './types';\n\n/**\n * 计算点到线段的垂直距离\n * @param point 点\n * @param lineStart 线段起点\n * @param lineEnd 线段终点\n * @returns 垂直距离\n */\nexport function perpendicularDistance(point: DataPoint, lineStart: DataPoint, lineEnd: DataPoint): number {\n  if (lineStart.x === lineEnd.x) {\n    return Math.abs(point.x - lineStart.x);\n  }\n  \n  const slope = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);\n  const intercept = lineStart.y - (slope * lineStart.x);\n  \n  // 点到直线的距离公式: |ax + by + c| / sqrt(a^2 + b^2)\n  // 其中直线方程为 ax + by + c = 0\n  // 转换为 y = mx + b 形式，则 a = -m, b = 1, c = -b\n  const a = -slope;\n  const b = 1;\n  const c = -intercept;\n  \n  return Math.abs(a * point.x + b * point.y + c) / Math.sqrt(a * a + b * b);\n}\n\n/**\n * Ramer-Douglas-Peucker 算法实现数据抽稀\n * @param points 原始数据点\n * @param epsilon 阈值，越小保留的点越多\n * @returns 抽稀后的数据点\n */\nexport function rdpAlgorithm(points: DataPoint[], epsilon: number): DataPoint[] {\n  if (points.length <= 2) {\n    return [...points];\n  }\n  \n  // 找到距离最远的点\n  let maxDistance = 0;\n  let maxIndex = 0;\n  \n  const firstPoint = points[0];\n  const lastPoint = points[points.length - 1];\n  \n  for (let i = 1; i < points.length - 1; i++) {\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      maxIndex = i;\n    }\n  }\n  \n  // 如果最大距离大于阈值，则递归处理\n  if (maxDistance > epsilon) {\n    const leftPoints = rdpAlgorithm(points.slice(0, maxIndex + 1), epsilon);\n    const rightPoints = rdpAlgorithm(points.slice(maxIndex), epsilon);\n    \n    // 合并结果，避免重复点\n    return [...leftPoints.slice(0, -1), ...rightPoints];\n  } else {\n    // 如果最大距离小于阈值，则只保留首尾两点\n    return [firstPoint, lastPoint];\n  }\n}\n\n/**\n * 格式化大数字，如50000 -> 50K\n * @param yTicks Y轴刻度值数组\n * @returns 格式化后的对象，键为原始值，值为格式化后的字符串\n */\nexport function formatLargeNumber(yTicks: number[]): Record<number, string> {\n  if (!yTicks || yTicks.length === 0) {\n    return {};\n  }\n  \n  // 创建结果对象\n  const result: Record<number, string> = {};\n  \n  // 格式化函数，根据小数位格式化数字\n  const format = (value: number, decimal: number): string => {\n    if (Math.abs(value) >= 1000000) {\n      return (value / 1000000).toFixed(decimal) + 'M';\n    } else if (Math.abs(value) >= 1000) {\n      return (value / 1000).toFixed(decimal) + 'K';\n    } else {\n      return decimal > 0 ? value.toFixed(decimal) : value.toString();\n    }\n  };\n  \n  // 检查格式化后是否有重复值\n  const hasUniqueFormats = (decimal: number): boolean => {\n    const formattedValues = yTicks.map(value => format(value, decimal));\n    const uniqueValues = new Set(formattedValues);\n    return uniqueValues.size === formattedValues.length;\n  };\n  \n  // 从0位小数开始，逐步增加小数位，直到没有重复值\n  let decimal = 0;\n  while (!hasUniqueFormats(decimal) && decimal < 6) {\n    decimal++;\n  }\n  \n  // 使用确定的小数位格式化所有值\n  yTicks.forEach(value => {\n    result[value] = format(value, decimal);\n  });\n  \n  return result;\n}\n\n/**\n * 防抖函数\n * @param fn 要执行的函数\n * @param delay 延迟时间\n * @returns 防抖处理后的函数\n */\nexport function debounce<T extends (...args: any[]) => any>(fn: T, delay: number): (...args: Parameters<T>) => void {\n  let timer: number | null = null;\n  \n  return function(this: any, ...args: Parameters<T>): void {\n    if (timer !== null) {\n      window.clearTimeout(timer);\n    }\n    \n    timer = window.setTimeout(() => {\n      fn.apply(this, args);\n      timer = null;\n    }, delay);\n  };\n}","import * as d3 from 'd3';\nimport { LineChartConfig, DataPoint, KeyPoint, KeyTick, DEFAULT_CONFIG } from './types';\nimport { rdpAlgorithm, formatLargeNumber, debounce } from './utils';\n\n/**\n * D3折线图Web Component\n */\nexport class D3LineChart extends HTMLElement {\n  // Shadow DOM\n  private shadow: ShadowRoot;\n  \n  // 容器元素\n  private container: HTMLDivElement;\n  private svgContainer: SVGSVGElement;\n  private canvasContainer: HTMLCanvasElement;\n  \n  // 画布上下文\n  private ctx: CanvasRenderingContext2D | null = null;\n  \n  // 数据和配置\n  private data: DataPoint[] = [];\n  private keyPoints: KeyPoint[] = [];\n  private keyTicks: KeyTick[] = [];\n  private config: LineChartConfig = { ...DEFAULT_CONFIG };\n  \n  // 尺寸和比例尺\n  private width: number = 0;\n  private height: number = 0;\n  private margin = { top: 20, right: 30, bottom: 40, left: 50 };\n  private xScale: d3.ScaleLinear<number, number> = d3.scaleLinear();\n  private yScale: d3.ScaleLinear<number, number> = d3.scaleLinear();\n  \n  // 动画相关\n  private animationProgress: number = 0;\n  private animationId: number | null = null;\n  \n  // 重绘防抖\n  private debouncedResize: () => void;\n  \n  constructor() {\n    super();\n    \n    // 创建Shadow DOM\n    this.shadow = this.attachShadow({ mode: 'open' });\n    \n    // 创建样式\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        width: 100%;\n        height: 100%;\n      }\n      \n      .container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n      \n      canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n      \n      svg {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n      }\n      \n      .key-point {\n        position: absolute;\n        transform: translateX(-50%);\n        z-index: 10;\n        pointer-events: auto;\n      }\n    `;\n    \n    // 创建容器\n    this.container = document.createElement('div');\n    this.container.className = 'container';\n    \n    // 创建Canvas\n    this.canvasContainer = document.createElement('canvas');\n    this.ctx = this.canvasContainer.getContext('2d');\n    \n    // 创建SVG\n    this.svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    \n    // 添加元素到Shadow DOM\n    this.container.appendChild(this.canvasContainer);\n    this.container.appendChild(this.svgContainer);\n    this.shadow.appendChild(style);\n    this.shadow.appendChild(this.container);\n    \n    // 初始化防抖重绘函数\n    this.debouncedResize = debounce(this.resize.bind(this), 200);\n    \n    // 监听窗口大小变化\n    this.setupResizeObserver();\n  }\n  \n  /**\n   * 当元素被添加到DOM时调用\n   */\n  connectedCallback() {\n    this.resize();\n  }\n  \n  /**\n   * 当元素从DOM中移除时调用\n   */\n  disconnectedCallback() {\n    // 清除动画\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n  \n  /**\n   * 设置配置\n   * @param config 配置对象\n   */\n  setConfig(config: Partial<LineChartConfig>) {\n    this.config = { ...this.config, ...config };\n    \n    // 更新margin配置\n    if (config.margin) {\n      this.margin = {\n        top: config.margin.top !== undefined ? config.margin.top : this.margin.top,\n        right: config.margin.right !== undefined ? config.margin.right : this.margin.right,\n        bottom: config.margin.bottom !== undefined ? config.margin.bottom : this.margin.bottom,\n        left: config.margin.left !== undefined ? config.margin.left : this.margin.left\n      };\n    }\n    \n    this.render();\n    return this;\n  }\n  \n  /**\n   * 获取margin配置\n   */\n  getMargin(): { top: number; right: number; bottom: number; left: number } {\n    return { ...this.margin };\n  }\n  \n  /**\n   * 设置是否启用动画\n   * @param enable 是否启用\n   * @param duration 动画时长（毫秒）\n   */\n  setEnableAnimation(enable: boolean, duration?: number) {\n    this.config.enableAnimation = enable;\n    if (duration !== undefined) {\n      this.config.animationDuration = duration;\n    }\n    return this;\n  }\n  \n  /**\n   * 设置数据\n   * @param data 数据点数组\n   */\n  setData(data: DataPoint[]) {\n    this.data = [...data];\n    \n    // 重置动画进度\n    this.animationProgress = 0;\n    \n    // 更新比例尺\n    this.updateScales();\n    \n    // 渲染图表\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 设置关键点\n   * @param keyPoints 关键点数组\n   */\n  setKeyPoints(keyPoints: KeyPoint[]) {\n    this.keyPoints = [...keyPoints];\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 设置关键刻度点\n   * @param keyTicks 关键刻度点数组\n   */\n  setKeyTicks(keyTicks: KeyTick[]) {\n    this.keyTicks = [...keyTicks];\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 获取配置\n   */\n  getConfig(): LineChartConfig {\n    return { ...this.config };\n  }\n  \n  /**\n   * 获取是否启用动画\n   */\n  getEnableAnimation(): boolean {\n    return !!this.config.enableAnimation;\n  }\n  \n  /**\n   * 获取动画时长\n   */\n  getAnimationDuration(): number {\n    return this.config.animationDuration || DEFAULT_CONFIG.animationDuration!;\n  }\n  \n  /**\n   * 获取网格线颜色\n   */\n  getGridColor(): string {\n    return this.config.gridColor || DEFAULT_CONFIG.gridColor!;\n  }\n  \n  /**\n   * 获取折线颜色\n   */\n  getLineColor(): string {\n    return this.config.lineColor || DEFAULT_CONFIG.lineColor!;\n  }\n  \n  /**\n   * 获取是否显示阴影\n   */\n  getShowShadow(): boolean {\n    return this.config.showShadow !== undefined ? this.config.showShadow : DEFAULT_CONFIG.showShadow!;\n  }\n  \n  /**\n   * 获取坐标轴文本颜色\n   */\n  getAxisTextColor(): string {\n    return this.config.axisTextColor || DEFAULT_CONFIG.axisTextColor!;\n  }\n  \n  /**\n   * 获取坐标轴文本大小\n   */\n  getAxisTextSize(): string {\n    return this.config.axisTextSize || DEFAULT_CONFIG.axisTextSize!;\n  }\n  \n  /**\n   * 获取数据\n   */\n  getData(): DataPoint[] {\n    return [...this.data];\n  }\n  \n  /**\n   * 获取关键点\n   */\n  getKeyPoints(): KeyPoint[] {\n    return [...this.keyPoints];\n  }\n  \n  /**\n   * 获取关键刻度点\n   */\n  getKeyTicks(): KeyTick[] {\n    return [...this.keyTicks];\n  }\n  \n  /**\n   * 获取曲线类型\n   */\n  getCurveType(): 'linear' | 'curve' {\n    return this.config.curveType || DEFAULT_CONFIG.curveType!;\n  }\n  \n  /**\n   * 设置ResizeObserver监听大小变化\n   */\n  private setupResizeObserver() {\n    // 使用ResizeObserver监听容器大小变化\n    const resizeObserver = new ResizeObserver(() => {\n      this.debouncedResize();\n    });\n    \n    resizeObserver.observe(this);\n    \n    // 初始调整大小\n    this.resize();\n  }\n  \n  /**\n   * 调整大小\n   */\n  private resize() {\n    const rect = this.getBoundingClientRect();\n    this.width = rect.width;\n    this.height = rect.height;\n    \n    // 设置Canvas大小\n    this.canvasContainer.width = this.width * window.devicePixelRatio;\n    this.canvasContainer.height = this.height * window.devicePixelRatio;\n    this.canvasContainer.style.width = `${this.width}px`;\n    this.canvasContainer.style.height = `${this.height}px`;\n    \n    // 调整Canvas缩放\n    if (this.ctx) {\n      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    }\n    \n    // 更新比例尺\n    this.updateScales();\n    \n    // 重新渲染\n    this.render();\n  }\n  \n  /**\n   * 更新比例尺\n   */\n  private updateScales() {\n    if (this.data.length === 0) return;\n    \n    // 计算数据范围\n    const xExtent = d3.extent(this.data, d => d.x) as [number, number];\n    const yExtent = d3.extent(this.data, d => d.y) as [number, number];\n    \n    // 设置比例尺\n    this.xScale = d3.scaleLinear()\n      .domain(xExtent)\n      .range([this.margin.left, this.width - this.margin.right]);\n    \n    this.yScale = d3.scaleLinear()\n      .domain(yExtent)\n      .range([this.height - this.margin.bottom, this.margin.top]);\n  }\n  \n  /**\n   * 渲染图表\n   */\n  private render() {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 清除画布\n    this.ctx.clearRect(0, 0, this.width, this.height);\n    \n    // 清除SVG内容\n    while (this.svgContainer.firstChild) {\n      this.svgContainer.removeChild(this.svgContainer.firstChild);\n    }\n    \n    // 移除所有关键点DOM元素\n    const keyPointElements = this.shadow.querySelectorAll('.key-point');\n    keyPointElements.forEach(el => el.remove());\n    \n    // 调整Y轴比例尺\n    this.extendYScaleDomain();\n    \n    // 绘制网格线和坐标轴\n    this.drawGridAndAxis();\n    \n    // 绘制折线\n    if (this.config.enableAnimation) {\n      this.startAnimation();\n    } else {\n      this.drawLine(1);\n      this.renderKeyPoints();\n    }\n  }\n  \n  /**\n   * 扩展Y轴比例尺域，以便更好地显示数据\n   */\n  private extendYScaleDomain(): void {\n    // 生成Y轴刻度\n    let yTicks = this.yScale.ticks(this.getTickCount());\n    \n    // 计算刻度间距并添加一个额外的更小刻度\n    if (yTicks.length >= 2) {\n      // 对刻度进行排序（从小到大）\n      yTicks.sort((a, b) => a - b);\n      \n      // 获取数据的最小值\n      const dataMin = d3.min(this.data, d => d.y) || 0;\n      \n      // 只有当最小刻度值大于数据的最小值时，才进行扩展\n      if (yTicks[0] > dataMin) {\n        // 计算最小的刻度间距\n        const minTickDiff = yTicks[1] - yTicks[0];\n        \n        // 创建一个比最小刻度更小的刻度\n        const extraTick = yTicks[0] - minTickDiff;\n        \n        // 调整domain，使其包含extraTick\n        const currentDomain = this.yScale.domain();\n        this.yScale.domain([extraTick, currentDomain[1]]);\n      }\n    }\n  }\n  \n  /**\n   * 获取刻度数量\n   */\n  private getTickCount(): number {\n    return this.config.tickCount || DEFAULT_CONFIG.tickCount || 5;\n  }\n  \n  /**\n   * 绘制网格线和坐标轴\n   */\n  private drawGridAndAxis() {\n    // 清除之前的元素\n    d3.select(this.svgContainer).selectAll('*').remove();\n    \n    const g = d3.select(this.svgContainer);\n    \n    // 使用已调整好的比例尺生成刻度\n    let yTicks = this.yScale.ticks(this.getTickCount());\n    // 格式化刻度值\n    const formattedTicksMap = formatLargeNumber(yTicks);\n    \n    // 测量文本宽度的临时SVG文本元素\n    const tempText = g.append('text')\n      .attr('class', 'temp-text')\n      .attr('font-size', this.getAxisTextSize())\n      .style('visibility', 'hidden');\n    \n    // 计算格式化后的数字宽度\n    const getTextWidth = (text: string): number => {\n      tempText.text(text);\n      return (tempText.node() as SVGTextElement)?.getBBox().width || 0;\n    };\n    \n    // 计算最大宽度\n    const formattedValues = Object.values(formattedTicksMap);\n    const maxWidth = Math.max(...formattedValues.map(getTextWidth));\n\n    // 计算新的左侧边距（文本宽度 + margin.left + 10）\n    const newLeftMargin = this.margin.left + maxWidth + 10;\n\n    // 移除临时文本元素\n    tempText.remove();\n\n    // 绘制横向网格线（Y轴网格线）\n    g.selectAll('.grid-line-y')\n      .data(yTicks)\n      .enter()\n      .append('line')\n      .attr('class', 'grid-line-y')\n      .attr('x1', newLeftMargin)\n      .attr('x2', this.width - this.margin.right)\n      .attr('y1', d => this.yScale(d))\n      .attr('y2', d => this.yScale(d))\n      .attr('stroke', this.getGridColor())\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n    \n    // 绘制Y轴刻度值\n    g.selectAll('.y-axis-label')\n      .data(yTicks)\n      .enter()\n      .append('text')\n      .attr('class', 'y-axis-label')\n      .attr('x', newLeftMargin -10) // 根据文本宽度调整位置\n      .attr('y', d => this.yScale(d))\n      .attr('dy', '0.32em')\n      .attr('text-anchor', 'end')\n      .attr('fill', this.getAxisTextColor())\n      .attr('font-size', this.getAxisTextSize())\n      .text(d => formattedTicksMap[d]);\n    \n    // 绘制X轴（与额外添加的最小刻度对齐）\n    g.append('line')\n      .attr('class', 'x-axis')\n      .attr('x1', newLeftMargin)\n      .attr('x2', this.width - this.margin.right)\n      .attr('y1', this.yScale(yTicks[0])) // 使用新添加的最小刻度\n      .attr('y2', this.yScale(yTicks[0])) // 使用新添加的最小刻度\n      .attr('stroke', this.getGridColor())\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n    \n    // 绘制关键刻度点\n    if (this.keyTicks.length > 0) {\n      g.selectAll('.key-tick')\n        .data(this.keyTicks)\n        .enter()\n        .append('text')\n        .attr('class', 'key-tick')\n        .attr('x', d => this.xScale(d.x))\n        .attr('y', this.yScale(yTicks[0]) + 20) // 将关键刻度点放在X轴下方20像素处\n        .attr('text-anchor', 'middle')\n        .attr('fill', this.getAxisTextColor())\n        .attr('font-size', this.getAxisTextSize())\n        .text(d => d.label);\n    }\n  }\n  \n  /**\n   * 绘制折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 根据配置选择绘制方式\n    if (this.getCurveType() === 'curve') {\n      this.drawCurveLine(progress);\n    } else {\n      this.drawLinearLine(progress);\n    }\n  }\n  \n  /**\n   * 绘制直线折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawLinearLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 获取当前的左侧边距\n    const g = d3.select(this.svgContainer);\n    const xAxisLine = g.select('.x-axis');\n    let leftMargin = this.margin.left;\n    \n    // 如果已经设置了新的左侧边距，则使用它\n    if (xAxisLine.attr('x1')) {\n      leftMargin = parseFloat(xAxisLine.attr('x1'));\n    }\n    \n    // 应用数据抽稀\n    const epsilon = 0.6; // 抽稀阈值\n    const simplifiedData = rdpAlgorithm(this.data, epsilon);\n    \n    // 计算动画进度对应的数据点数量\n    const dataLength = Math.floor(simplifiedData.length * progress);\n    const animatedData = simplifiedData.slice(0, dataLength);\n    \n    if (animatedData.length < 2) return;\n    \n    // 创建新的比例尺，使用调整后的左侧边距\n    const adjustedXScale = d3.scaleLinear()\n      .domain([d3.min(this.data, d => d.x) || 0, d3.max(this.data, d => d.x) || 0])\n      .range([leftMargin, this.width - this.margin.right]);\n    \n    // 绘制折线\n    this.ctx.save();\n    this.ctx.beginPath();\n    \n    this.ctx.moveTo(adjustedXScale(animatedData[0].x), this.yScale(animatedData[0].y));\n    \n    for (let i = 1; i < animatedData.length; i++) {\n      this.ctx.lineTo(adjustedXScale(animatedData[i].x), this.yScale(animatedData[i].y));\n    }\n    \n    this.ctx.strokeStyle = this.getLineColor();\n    this.ctx.lineWidth = 2;\n    this.ctx.stroke();\n    \n    // 绘制阴影\n    if (this.getShowShadow()) {\n      // 继续路径以闭合区域\n      this.ctx.lineTo(adjustedXScale(animatedData[animatedData.length - 1].x), this.height - this.margin.bottom);\n      this.ctx.lineTo(adjustedXScale(animatedData[0].x), this.height - this.margin.bottom);\n      this.ctx.closePath();\n      \n      // 创建渐变\n      const gradient = this.ctx.createLinearGradient(0, this.margin.top, 0, this.height - this.margin.bottom);\n      const color = this.getLineColor();\n      gradient.addColorStop(0, `${color}80`); // 50% 透明度\n      gradient.addColorStop(1, `${color}00`); // 0% 透明度\n      \n      this.ctx.fillStyle = gradient;\n      this.ctx.fill();\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 绘制曲线折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawCurveLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 获取当前的左侧边距\n    const g = d3.select(this.svgContainer);\n    const xAxisLine = g.select('.x-axis');\n    let leftMargin = this.margin.left;\n    \n    // 如果已经设置了新的左侧边距，则使用它\n    if (xAxisLine.attr('x1')) {\n      leftMargin = parseFloat(xAxisLine.attr('x1'));\n    }\n    \n    // 应用数据抽稀\n    const epsilon = 0.6; // 抽稀阈值\n    const simplifiedData = rdpAlgorithm(this.data, epsilon);\n    \n    // 计算动画进度对应的数据点数量\n    const dataLength = Math.floor(simplifiedData.length * progress);\n    const animatedData = simplifiedData.slice(0, dataLength);\n    \n    if (animatedData.length < 2) return;\n    \n    // 创建新的比例尺，使用调整后的左侧边距\n    const adjustedXScale = d3.scaleLinear()\n      .domain([d3.min(this.data, d => d.x) || 0, d3.max(this.data, d => d.x) || 0])\n      .range([leftMargin, this.width - this.margin.right]);\n    \n    // 使用D3的line生成器和曲线插值器\n    const line = d3.line<DataPoint>()\n      .x(d => adjustedXScale(d.x))\n      .y(d => this.yScale(d.y))\n      .curve(d3.curveCatmullRom.alpha(0.5)); // 使用CatmullRom曲线，alpha控制曲线张力\n    \n    // 获取路径数据\n    const pathData = line(animatedData);\n    \n    if (!pathData) return;\n    \n    // 绘制曲线\n    this.ctx.save();\n    this.ctx.beginPath();\n    \n    // 使用路径数据绘制\n    const path = new Path2D(pathData);\n    this.ctx.strokeStyle = this.getLineColor();\n    this.ctx.lineWidth = 2;\n    this.ctx.stroke(path);\n    \n    // 绘制阴影\n    if (this.getShowShadow()) {\n      this.ctx.beginPath();\n      \n      // 创建一个新的路径用于填充阴影区域\n      const areaPath = new Path2D(pathData);\n      \n      // 添加闭合区域的路径\n      areaPath.lineTo(adjustedXScale(animatedData[animatedData.length - 1].x), this.height - this.margin.bottom);\n      areaPath.lineTo(adjustedXScale(animatedData[0].x), this.height - this.margin.bottom);\n      areaPath.closePath();\n      \n      // 创建渐变\n      const gradient = this.ctx.createLinearGradient(0, this.margin.top, 0, this.height - this.margin.bottom);\n      const color = this.getLineColor();\n      gradient.addColorStop(0, `${color}80`); // 50% 透明度\n      gradient.addColorStop(1, `${color}00`); // 0% 透明度\n      \n      this.ctx.fillStyle = gradient;\n      this.ctx.fill(areaPath);\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 渲染关键点\n   */\n  private renderKeyPoints() {\n    // 过滤出在坐标范围内的关键点\n    const validKeyPoints = this.keyPoints.filter(point => {\n      const x = this.xScale(point.x);\n      const y = this.yScale(point.y);\n      \n      return (\n        x >= this.margin.left &&\n        x <= this.width - this.margin.right &&\n        y >= this.margin.top &&\n        y <= this.height - this.margin.bottom\n      );\n    });\n    \n    // 为每个关键点创建DOM元素\n    validKeyPoints.forEach(point => {\n      const keyPointElement = document.createElement('div');\n      keyPointElement.className = 'key-point';\n      \n      // 计算X轴位置\n      const xAxisY = this.height - this.margin.bottom;\n      \n      // 获取数据点的Y坐标\n      const pointY = this.yScale(point.y);\n      \n      // 创建临时元素来测量尺寸\n      const tempElement = document.createElement('div');\n      tempElement.className = 'key-point';\n      tempElement.innerHTML = point.render;\n      tempElement.style.position = 'absolute';\n      tempElement.style.visibility = 'hidden';\n      this.container.appendChild(tempElement);\n      \n      // 获取元素尺寸\n      const elementHeight = tempElement.offsetHeight;\n      const elementWidth = tempElement.offsetWidth;\n      \n      // 移除临时元素\n      this.container.removeChild(tempElement);\n      \n      // 计算关键点的X坐标\n      const pointX = this.xScale(point.x);\n      \n      // 检查是否会超出右边界（考虑到transform: translateX(-50%)的影响，实际宽度是elementWidth/2）\n      const rightEdgePosition = pointX + elementWidth / 2;\n      const isExceedingRightBoundary = rightEdgePosition > (this.width - this.margin.right);\n      \n      // 调整X位置，确保不超出右边界\n      let leftPosition = pointX;\n      if (isExceedingRightBoundary) {\n        // 将元素右对齐到右边界\n        leftPosition = this.width - this.margin.right - elementWidth / 2;\n      }\n      \n      // 设置左侧位置\n      keyPointElement.style.left = `${leftPosition}px`;\n      \n      // 定义接近X轴的阈值（例如：距离X轴不到元素高度的2倍）\n      const proximityThreshold = elementHeight * 2;\n      \n      // 判断点是否靠近X轴\n      const isCloseToXAxis = (xAxisY - pointY) < proximityThreshold;\n      \n      // 计算top位置\n      let topPosition;\n\n      if (isCloseToXAxis) {\n        // 如果靠近X轴，将关键点显示在数据点上方\n        topPosition = pointY - elementHeight;\n        \n        // 确保不超出上边界\n        if (topPosition < this.margin.top) {\n          topPosition = this.margin.top;\n        }\n      } else {\n        // 如果不靠近X轴，保持在数据点位置\n        topPosition = pointY - 20;\n      }\n\n      // 设置top位置\n      keyPointElement.style.top = `${topPosition}px`;\n      \n      keyPointElement.innerHTML = point.render;\n      \n      this.container.appendChild(keyPointElement);\n    });\n  }\n  \n  /**\n   * 开始动画\n   */\n  private startAnimation() {\n    // 清除之前的动画\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n    \n    // 重置动画进度\n    this.animationProgress = 0;\n    \n    // 动画开始时间\n    const startTime = performance.now();\n    const duration = this.getAnimationDuration();\n    \n    // 动画函数\n    const animate = (currentTime: number) => {\n      // 计算动画进度\n      const elapsed = currentTime - startTime;\n      this.animationProgress = Math.min(elapsed / duration, 1);\n      \n      // 清除画布\n      if (this.ctx) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n      }\n      \n      // 绘制折线\n      this.drawLine(this.animationProgress);\n      \n      // 如果动画未完成，继续下一帧\n      if (this.animationProgress < 1) {\n        this.animationId = requestAnimationFrame(animate);\n      } else {\n        // 动画完成，渲染关键点\n        this.renderKeyPoints();\n        this.animationId = null;\n      }\n    };\n    \n    // 开始动画\n    this.animationId = requestAnimationFrame(animate);\n  }\n}\n\n// 注册Web Component\ncustomElements.define('d3-line-chart', D3LineChart);\n"],"names":["DEFAULT_CONFIG","lineColor","showShadow","gridColor","enableAnimation","animationDuration","axisTextColor","axisTextSize","curveType","tickCount","margin","top","right","bottom","left","perpendicularDistance","point","lineStart","lineEnd","x","Math","abs","slope","y","a","c","sqrt","b","rdpAlgorithm","points","epsilon","length","maxDistance","maxIndex","firstPoint","lastPoint","i","distance","leftPoints","slice","rightPoints","D3LineChart","HTMLElement","constructor","super","this","ctx","data","keyPoints","keyTicks","config","width","height","xScale","d3","scaleLinear","yScale","animationProgress","animationId","shadow","attachShadow","mode","style","document","createElement","textContent","container","className","canvasContainer","getContext","svgContainer","createElementNS","appendChild","debouncedResize","fn","delay","timer","args","window","clearTimeout","setTimeout","apply","debounce","resize","bind","setupResizeObserver","connectedCallback","disconnectedCallback","cancelAnimationFrame","setConfig","undefined","render","getMargin","setEnableAnimation","enable","duration","setData","updateScales","setKeyPoints","setKeyTicks","getConfig","getEnableAnimation","getAnimationDuration","getGridColor","getLineColor","getShowShadow","getAxisTextColor","getAxisTextSize","getData","getKeyPoints","getKeyTicks","getCurveType","ResizeObserver","observe","rect","getBoundingClientRect","devicePixelRatio","scale","xExtent","extent","d","yExtent","domain","range","clearRect","firstChild","removeChild","querySelectorAll","forEach","el","remove","extendYScaleDomain","drawGridAndAxis","startAnimation","drawLine","renderKeyPoints","yTicks","ticks","getTickCount","sort","dataMin","min","minTickDiff","extraTick","currentDomain","select","selectAll","g","formattedTicksMap","result","format","value","decimal","toFixed","toString","hasUniqueFormats","formattedValues","map","Set","size","formatLargeNumber","tempText","append","attr","Object","values","maxWidth","max","text","node","getBBox","newLeftMargin","enter","label","progress","drawCurveLine","drawLinearLine","xAxisLine","leftMargin","parseFloat","simplifiedData","dataLength","floor","animatedData","adjustedXScale","save","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","closePath","gradient","createLinearGradient","color","addColorStop","fillStyle","fill","restore","pathData","line","curve","curveCatmullRom","alpha","path","Path2D","areaPath","filter","keyPointElement","xAxisY","pointY","tempElement","innerHTML","position","visibility","elementHeight","offsetHeight","elementWidth","offsetWidth","pointX","leftPosition","topPosition","startTime","performance","now","animate","currentTime","elapsed","requestAnimationFrame","customElements","define"],"mappings":"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"}