{"version":3,"file":"d3-line-chart.min.js","sources":["../src/types.ts","../src/utils.ts","../src/d3-line-chart.ts"],"sourcesContent":["// 折线图配置接口\nexport interface LineChartConfig {\n  lineColor?: string;        // 折线颜色\n  showShadow?: boolean;      // 是否显示阴影\n  gridColor?: string;        // 网格线颜色\n  enableAnimation?: boolean; // 是否启用动画\n  animationDuration?: number; // 动画时长\n  axisTextColor?: string;    // 坐标轴文本颜色\n  axisTextSize?: string;     // 坐标轴文本字体大小\n  curveType?: 'linear' | 'curve'; // 折线类型：直线或曲线\n  tickCount?: number;        // Y轴刻度数量\n  margin?: {                 // 图表边距\n    top?: number;            // 上边距\n    right?: number;          // 右边距\n    bottom?: number;         // 下边距\n    left?: number;           // 左边距\n  };\n}\n\n// 数据点接口\nexport interface DataPoint {\n  x: number;\n  y: number;\n}\n\n// 关键点接口\nexport interface KeyPoint extends DataPoint {\n  render: string; // 关键点的渲染HTML\n}\n\n// 关键刻度点接口\nexport interface KeyTick {\n  x: number;\n  label: string;\n}\n\n// 默认配置\nexport const DEFAULT_CONFIG: LineChartConfig = {\n  lineColor: '#3498db',\n  showShadow: true,\n  gridColor: '#e0e0e0',\n  enableAnimation: true,\n  animationDuration: 1000,\n  axisTextColor: '#333333',\n  axisTextSize: '12px',\n  curveType: 'linear',\n  tickCount: 5,\n  margin: {\n    top: 20,\n    right: 30,\n    bottom: 40,\n    left: 50\n  }\n};\n","import { DataPoint } from './types';\n\n/**\n * 计算点到线段的垂直距离\n * @param point 点\n * @param lineStart 线段起点\n * @param lineEnd 线段终点\n * @returns 垂直距离\n */\nexport function perpendicularDistance(point: DataPoint, lineStart: DataPoint, lineEnd: DataPoint): number {\n  if (lineStart.x === lineEnd.x) {\n    return Math.abs(point.x - lineStart.x);\n  }\n  \n  const slope = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);\n  const intercept = lineStart.y - (slope * lineStart.x);\n  \n  // 点到直线的距离公式: |ax + by + c| / sqrt(a^2 + b^2)\n  // 其中直线方程为 ax + by + c = 0\n  // 转换为 y = mx + b 形式，则 a = -m, b = 1, c = -b\n  const a = -slope;\n  const b = 1;\n  const c = -intercept;\n  \n  return Math.abs(a * point.x + b * point.y + c) / Math.sqrt(a * a + b * b);\n}\n\n/**\n * Ramer-Douglas-Peucker 算法实现数据抽稀\n * @param points 原始数据点\n * @param epsilon 阈值，越小保留的点越多\n * @returns 抽稀后的数据点\n */\nexport function rdpAlgorithm(points: DataPoint[], epsilon: number): DataPoint[] {\n  // 如果数据点少于70个，不进行抽稀\n  if (points.length < 70) {\n    return [...points];\n  }\n  \n  // 找到距离最远的点\n  let maxDistance = 0;\n  let maxIndex = 0;\n  \n  const firstPoint = points[0];\n  const lastPoint = points[points.length - 1];\n  \n  for (let i = 1; i < points.length - 1; i++) {\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      maxIndex = i;\n    }\n  }\n  \n  // 如果最大距离大于阈值，则递归处理\n  if (maxDistance > epsilon) {\n    const leftPoints = rdpAlgorithm(points.slice(0, maxIndex + 1), epsilon);\n    const rightPoints = rdpAlgorithm(points.slice(maxIndex), epsilon);\n    \n    // 合并结果，避免重复点\n    return [...leftPoints.slice(0, -1), ...rightPoints];\n  } else {\n    // 如果最大距离小于阈值，则只保留首尾两点\n    return [firstPoint, lastPoint];\n  }\n}\n\n/**\n * 格式化大数字，如50000 -> 50K\n * @param yTicks Y轴刻度值数组\n * @returns 格式化后的对象，键为原始值，值为格式化后的字符串\n */\nexport function formatLargeNumber(yTicks: number[]): Record<number, string> {\n  if (!yTicks || yTicks.length === 0) {\n    return {};\n  }\n  \n  // 创建结果对象\n  const result: Record<number, string> = {};\n  \n  // 格式化函数，根据小数位格式化数字\n  const format = (value: number, decimal: number): string => {\n    if (Math.abs(value) >= 1000000) {\n      return (value / 1000000).toFixed(decimal) + 'M';\n    } else if (Math.abs(value) >= 1000) {\n      return (value / 1000).toFixed(decimal) + 'K';\n    } else {\n      return decimal > 0 ? value.toFixed(decimal) : value.toString();\n    }\n  };\n  \n  // 检查格式化后是否有重复值\n  const hasUniqueFormats = (decimal: number): boolean => {\n    const formattedValues = yTicks.map(value => format(value, decimal));\n    const uniqueValues = new Set(formattedValues);\n    return uniqueValues.size === formattedValues.length;\n  };\n  \n  // 从0位小数开始，逐步增加小数位，直到没有重复值\n  let decimal = 0;\n  while (!hasUniqueFormats(decimal) && decimal < 6) {\n    decimal++;\n  }\n  \n  // 使用确定的小数位格式化所有值\n  yTicks.forEach(value => {\n    result[value] = format(value, decimal);\n  });\n  \n  return result;\n}\n\n/**\n * 防抖函数\n * @param fn 要执行的函数\n * @param delay 延迟时间\n * @returns 防抖处理后的函数\n */\nexport function debounce<T extends (...args: any[]) => any>(fn: T, delay: number): (...args: Parameters<T>) => void {\n  let timer: number | null = null;\n  \n  return function(this: any, ...args: Parameters<T>): void {\n    if (timer !== null) {\n      window.clearTimeout(timer);\n    }\n    \n    timer = window.setTimeout(() => {\n      fn.apply(this, args);\n      timer = null;\n    }, delay);\n  };\n}","import * as d3 from 'd3';\nimport { LineChartConfig, DataPoint, KeyPoint, KeyTick, DEFAULT_CONFIG } from './types';\nimport { rdpAlgorithm, formatLargeNumber, debounce } from './utils';\n\n/**\n * D3折线图Web Component\n */\nexport class D3LineChart extends HTMLElement {\n  // Shadow DOM\n  private shadow: ShadowRoot;\n  \n  // 容器元素\n  private container: HTMLDivElement;\n  private svgContainer: SVGSVGElement;\n  private canvasContainer: HTMLCanvasElement;\n  \n  // 画布上下文\n  private ctx: CanvasRenderingContext2D | null = null;\n  \n  // 数据和配置\n  private data: DataPoint[] = [];\n  private keyPoints: KeyPoint[] = [];\n  private keyTicks: KeyTick[] = [];\n  private config: LineChartConfig = { ...DEFAULT_CONFIG };\n  \n  // 尺寸和比例尺\n  private width: number = 0;\n  private height: number = 0;\n  private margin = { top: 20, right: 30, bottom: 40, left: 50 };\n  private xScale: d3.ScaleLinear<number, number> = d3.scaleLinear();\n  private yScale: d3.ScaleLinear<number, number> = d3.scaleLinear();\n  \n  // 动画相关\n  private animationProgress: number = 0;\n  private animationId: number | null = null;\n  \n  // 重绘防抖\n  private debouncedResize: () => void;\n  \n  constructor() {\n    super();\n    \n    // 创建Shadow DOM\n    this.shadow = this.attachShadow({ mode: 'open' });\n    \n    // 创建样式\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        width: 100%;\n        height: 100%;\n      }\n      \n      .container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n      \n      canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n      \n      svg {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n      }\n      \n      .key-point {\n        position: absolute;\n        transform: translateX(-50%);\n        z-index: 10;\n        pointer-events: auto;\n      }\n    `;\n    \n    // 创建容器\n    this.container = document.createElement('div');\n    this.container.className = 'container';\n    \n    // 创建Canvas\n    this.canvasContainer = document.createElement('canvas');\n    this.ctx = this.canvasContainer.getContext('2d');\n    \n    // 创建SVG\n    this.svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    \n    // 添加元素到Shadow DOM\n    this.container.appendChild(this.canvasContainer);\n    this.container.appendChild(this.svgContainer);\n    this.shadow.appendChild(style);\n    this.shadow.appendChild(this.container);\n    \n    // 初始化防抖重绘函数\n    this.debouncedResize = debounce(this.resize.bind(this), 200);\n    \n    // 监听窗口大小变化\n    this.setupResizeObserver();\n  }\n  \n  /**\n   * 当元素被添加到DOM时调用\n   */\n  connectedCallback() {\n    this.resize();\n  }\n  \n  /**\n   * 当元素从DOM中移除时调用\n   */\n  disconnectedCallback() {\n    // 清除动画\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n  \n  /**\n   * 设置配置\n   * @param config 配置对象\n   */\n  setConfig(config: Partial<LineChartConfig>) {\n    this.config = { ...this.config, ...config };\n    \n    // 更新margin配置\n    if (config.margin) {\n      this.margin = {\n        top: config.margin.top !== undefined ? config.margin.top : this.margin.top,\n        right: config.margin.right !== undefined ? config.margin.right : this.margin.right,\n        bottom: config.margin.bottom !== undefined ? config.margin.bottom : this.margin.bottom,\n        left: config.margin.left !== undefined ? config.margin.left : this.margin.left\n      };\n    }\n    \n    this.render();\n    return this;\n  }\n  \n  /**\n   * 获取margin配置\n   */\n  getMargin(): { top: number; right: number; bottom: number; left: number } {\n    return { ...this.margin };\n  }\n  \n  /**\n   * 设置是否启用动画\n   * @param enable 是否启用\n   * @param duration 动画时长（毫秒）\n   */\n  setEnableAnimation(enable: boolean, duration?: number) {\n    this.config.enableAnimation = enable;\n    if (duration !== undefined) {\n      this.config.animationDuration = duration;\n    }\n    return this;\n  }\n  \n  /**\n   * 设置数据\n   * @param data 数据点数组\n   */\n  setData(data: DataPoint[]) {\n    this.data = [...data];\n    \n    // 重置动画进度\n    this.animationProgress = 0;\n    \n    // 更新比例尺\n    this.updateScales();\n    \n    // 渲染图表\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 设置关键点\n   * @param keyPoints 关键点数组\n   */\n  setKeyPoints(keyPoints: KeyPoint[]) {\n    this.keyPoints = [...keyPoints];\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 设置关键刻度点\n   * @param keyTicks 关键刻度点数组\n   */\n  setKeyTicks(keyTicks: KeyTick[]) {\n    this.keyTicks = [...keyTicks];\n    this.render();\n    return this;\n  }\n  \n  /**\n   * 获取配置\n   */\n  getConfig(): LineChartConfig {\n    return { ...this.config };\n  }\n  \n  /**\n   * 获取是否启用动画\n   */\n  getEnableAnimation(): boolean {\n    return !!this.config.enableAnimation;\n  }\n  \n  /**\n   * 获取动画时长\n   */\n  getAnimationDuration(): number {\n    return this.config.animationDuration || DEFAULT_CONFIG.animationDuration!;\n  }\n  \n  /**\n   * 获取网格线颜色\n   */\n  getGridColor(): string {\n    return this.config.gridColor || DEFAULT_CONFIG.gridColor!;\n  }\n  \n  /**\n   * 获取折线颜色\n   */\n  getLineColor(): string {\n    return this.config.lineColor || DEFAULT_CONFIG.lineColor!;\n  }\n  \n  /**\n   * 获取是否显示阴影\n   */\n  getShowShadow(): boolean {\n    return this.config.showShadow !== undefined ? this.config.showShadow : DEFAULT_CONFIG.showShadow!;\n  }\n  \n  /**\n   * 获取坐标轴文本颜色\n   */\n  getAxisTextColor(): string {\n    return this.config.axisTextColor || DEFAULT_CONFIG.axisTextColor!;\n  }\n  \n  /**\n   * 获取坐标轴文本大小\n   */\n  getAxisTextSize(): string {\n    return this.config.axisTextSize || DEFAULT_CONFIG.axisTextSize!;\n  }\n  \n  /**\n   * 获取数据\n   */\n  getData(): DataPoint[] {\n    return [...this.data];\n  }\n  \n  /**\n   * 获取关键点\n   */\n  getKeyPoints(): KeyPoint[] {\n    return [...this.keyPoints];\n  }\n  \n  /**\n   * 获取关键刻度点\n   */\n  getKeyTicks(): KeyTick[] {\n    return [...this.keyTicks];\n  }\n  \n  /**\n   * 获取曲线类型\n   */\n  getCurveType(): 'linear' | 'curve' {\n    return this.config.curveType || DEFAULT_CONFIG.curveType!;\n  }\n  \n  /**\n   * 设置ResizeObserver监听大小变化\n   */\n  private setupResizeObserver() {\n    // 使用ResizeObserver监听容器大小变化\n    const resizeObserver = new ResizeObserver(() => {\n      this.debouncedResize();\n    });\n    \n    resizeObserver.observe(this);\n    \n    // 初始调整大小\n    this.resize();\n  }\n  \n  /**\n   * 调整大小\n   */\n  private resize() {\n    const rect = this.getBoundingClientRect();\n    this.width = rect.width;\n    this.height = rect.height;\n    \n    // 设置Canvas大小\n    this.canvasContainer.width = this.width * window.devicePixelRatio;\n    this.canvasContainer.height = this.height * window.devicePixelRatio;\n    this.canvasContainer.style.width = `${this.width}px`;\n    this.canvasContainer.style.height = `${this.height}px`;\n    \n    // 调整Canvas缩放\n    if (this.ctx) {\n      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    }\n    \n    // 更新比例尺\n    this.updateScales();\n    \n    // 重新渲染\n    this.render();\n  }\n  \n  /**\n   * 更新比例尺\n   */\n  private updateScales() {\n    if (this.data.length === 0) return;\n    \n    // 计算数据范围\n    const xExtent = d3.extent(this.data, d => d.x) as [number, number];\n    const yExtent = d3.extent(this.data, d => d.y) as [number, number];\n    \n    // 设置比例尺\n    this.xScale = d3.scaleLinear()\n      .domain(xExtent)\n      .range([this.margin.left, this.width - this.margin.right]);\n    \n    this.yScale = d3.scaleLinear()\n      .domain(yExtent)\n      .range([this.height - this.margin.bottom, this.margin.top]);\n  }\n  \n  /**\n   * 渲染图表\n   */\n  private render() {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 清除画布\n    this.ctx.clearRect(0, 0, this.width, this.height);\n    \n    // 清除SVG内容\n    while (this.svgContainer.firstChild) {\n      this.svgContainer.removeChild(this.svgContainer.firstChild);\n    }\n    \n    // 移除所有关键点DOM元素\n    const keyPointElements = this.shadow.querySelectorAll('.key-point');\n    keyPointElements.forEach(el => el.remove());\n    \n    // 调整Y轴比例尺\n    this.extendYScaleDomain();\n    \n    // 绘制网格线和坐标轴\n    this.drawGridAndAxis();\n    \n    // 绘制折线\n    if (this.config.enableAnimation) {\n      this.startAnimation();\n    } else {\n      this.drawLine(1);\n      this.renderKeyPoints();\n    }\n  }\n  \n  /**\n   * 扩展Y轴比例尺域，以便更好地显示数据\n   */\n  private extendYScaleDomain(): void {\n    // 生成Y轴刻度\n    let yTicks = this.yScale.ticks(this.getTickCount());\n    \n    // 计算刻度间距并添加一个额外的更小刻度\n    if (yTicks.length >= 2) {\n      // 对刻度进行排序（从小到大）\n      yTicks.sort((a, b) => a - b);\n      \n      // 获取数据的最小值\n      const dataMin = d3.min(this.data, d => d.y) || 0;\n      \n      // 只有当最小刻度值大于数据的最小值时，才进行扩展\n      if (yTicks[0] > dataMin) {\n        // 计算最小的刻度间距\n        const minTickDiff = yTicks[1] - yTicks[0];\n        \n        // 创建一个比最小刻度更小的刻度\n        const extraTick = yTicks[0] - minTickDiff;\n        \n        // 调整domain，使其包含extraTick\n        const currentDomain = this.yScale.domain();\n        this.yScale.domain([extraTick, currentDomain[1]]);\n      }\n    }\n  }\n  \n  /**\n   * 获取刻度数量\n   */\n  private getTickCount(): number {\n    return this.config.tickCount || DEFAULT_CONFIG.tickCount || 5;\n  }\n  \n  /**\n   * 绘制网格线和坐标轴\n   */\n  private drawGridAndAxis() {\n    // 清除之前的元素\n    d3.select(this.svgContainer).selectAll('*').remove();\n    \n    const g = d3.select(this.svgContainer);\n    \n    // 使用已调整好的比例尺生成刻度\n    let yTicks = this.yScale.ticks(this.getTickCount());\n    // 格式化刻度值\n    const formattedTicksMap = formatLargeNumber(yTicks);\n    \n    // 测量文本宽度的临时SVG文本元素\n    const tempText = g.append('text')\n      .attr('class', 'temp-text')\n      .attr('font-size', this.getAxisTextSize())\n      .style('visibility', 'hidden');\n    \n    // 计算格式化后的数字宽度\n    const getTextWidth = (text: string): number => {\n      tempText.text(text);\n      return (tempText.node() as SVGTextElement)?.getBBox().width || 0;\n    };\n    \n    // 计算最大宽度\n    const formattedValues = Object.values(formattedTicksMap);\n    const maxWidth = Math.max(...formattedValues.map(getTextWidth));\n\n    // 计算新的左侧边距（文本宽度 + margin.left + 10）\n    const newLeftMargin = this.margin.left + maxWidth + 10;\n\n    // 移除临时文本元素\n    tempText.remove();\n\n    // 绘制横向网格线（Y轴网格线）\n    g.selectAll('.grid-line-y')\n      .data(yTicks)\n      .enter()\n      .append('line')\n      .attr('class', 'grid-line-y')\n      .attr('x1', newLeftMargin)\n      .attr('x2', this.width - this.margin.right)\n      .attr('y1', d => this.yScale(d))\n      .attr('y2', d => this.yScale(d))\n      .attr('stroke', this.getGridColor())\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n    \n    // 绘制Y轴刻度值\n    g.selectAll('.y-axis-label')\n      .data(yTicks)\n      .enter()\n      .append('text')\n      .attr('class', 'y-axis-label')\n      .attr('x', newLeftMargin -10) // 根据文本宽度调整位置\n      .attr('y', d => this.yScale(d))\n      .attr('dy', '0.32em')\n      .attr('text-anchor', 'end')\n      .attr('fill', this.getAxisTextColor())\n      .attr('font-size', this.getAxisTextSize())\n      .text(d => formattedTicksMap[d]);\n    \n    // 绘制X轴（与额外添加的最小刻度对齐）\n    g.append('line')\n      .attr('class', 'x-axis')\n      .attr('x1', newLeftMargin)\n      .attr('x2', this.width - this.margin.right)\n      .attr('y1', this.yScale(yTicks[0])) // 使用新添加的最小刻度\n      .attr('y2', this.yScale(yTicks[0])) // 使用新添加的最小刻度\n      .attr('stroke', this.getGridColor())\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n    \n    // 绘制关键刻度点\n    if (this.keyTicks.length > 0) {\n      g.selectAll('.key-tick')\n        .data(this.keyTicks)\n        .enter()\n        .append('text')\n        .attr('class', 'key-tick')\n        .attr('x', d => this.xScale(d.x))\n        .attr('y', this.yScale(yTicks[0]) + 20) // 将关键刻度点放在X轴下方20像素处\n        .attr('text-anchor', 'middle')\n        .attr('fill', this.getAxisTextColor())\n        .attr('font-size', this.getAxisTextSize())\n        .text(d => d.label);\n    }\n  }\n  \n  /**\n   * 绘制折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 根据配置选择绘制方式\n    if (this.getCurveType() === 'curve') {\n      this.drawCurveLine(progress);\n    } else {\n      this.drawLinearLine(progress);\n    }\n  }\n  \n  /**\n   * 绘制直线折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawLinearLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 获取当前的左侧边距\n    const g = d3.select(this.svgContainer);\n    const xAxisLine = g.select('.x-axis');\n    let leftMargin = this.margin.left;\n    \n    // 如果已经设置了新的左侧边距，则使用它\n    if (xAxisLine.attr('x1')) {\n      leftMargin = parseFloat(xAxisLine.attr('x1'));\n    }\n    \n    // 应用数据抽稀\n    const epsilon = 0.6; // 抽稀阈值\n    const simplifiedData = rdpAlgorithm(this.data, epsilon);\n    \n    // 计算动画进度对应的数据点数量\n    const dataLength = Math.floor(simplifiedData.length * progress);\n    const animatedData = simplifiedData.slice(0, dataLength);\n    \n    if (animatedData.length < 2) return;\n    \n    // 创建新的比例尺，使用调整后的左侧边距\n    const adjustedXScale = d3.scaleLinear()\n      .domain([d3.min(this.data, d => d.x) || 0, d3.max(this.data, d => d.x) || 0])\n      .range([leftMargin, this.width - this.margin.right]);\n    \n    // 绘制折线\n    this.ctx.save();\n    this.ctx.beginPath();\n    \n    this.ctx.moveTo(adjustedXScale(animatedData[0].x), this.yScale(animatedData[0].y));\n    \n    for (let i = 1; i < animatedData.length; i++) {\n      this.ctx.lineTo(adjustedXScale(animatedData[i].x), this.yScale(animatedData[i].y));\n    }\n    \n    this.ctx.strokeStyle = this.getLineColor();\n    this.ctx.lineWidth = 2;\n    this.ctx.stroke();\n    \n    // 绘制阴影\n    if (this.getShowShadow()) {\n      // 继续路径以闭合区域\n      this.ctx.lineTo(adjustedXScale(animatedData[animatedData.length - 1].x), this.height - this.margin.bottom);\n      this.ctx.lineTo(adjustedXScale(animatedData[0].x), this.height - this.margin.bottom);\n      this.ctx.closePath();\n      \n      // 创建渐变\n      const gradient = this.ctx.createLinearGradient(0, this.margin.top, 0, this.height - this.margin.bottom);\n      const color = this.getLineColor();\n      gradient.addColorStop(0, `${color}80`); // 50% 透明度\n      gradient.addColorStop(1, `${color}00`); // 0% 透明度\n      \n      this.ctx.fillStyle = gradient;\n      this.ctx.fill();\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 绘制曲线折线\n   * @param progress 动画进度 (0-1)\n   */\n  private drawCurveLine(progress: number) {\n    if (!this.ctx || this.data.length === 0) return;\n    \n    // 获取当前的左侧边距\n    const g = d3.select(this.svgContainer);\n    const xAxisLine = g.select('.x-axis');\n    let leftMargin = this.margin.left;\n    \n    // 如果已经设置了新的左侧边距，则使用它\n    if (xAxisLine.attr('x1')) {\n      leftMargin = parseFloat(xAxisLine.attr('x1'));\n    }\n    \n    // 应用数据抽稀\n    const epsilon = 0.6; // 抽稀阈值\n    const simplifiedData = rdpAlgorithm(this.data, epsilon);\n    \n    // 计算动画进度对应的数据点数量\n    const dataLength = Math.floor(simplifiedData.length * progress);\n    const animatedData = simplifiedData.slice(0, dataLength);\n    \n    if (animatedData.length < 2) return;\n    \n    // 创建新的比例尺，使用调整后的左侧边距\n    const adjustedXScale = d3.scaleLinear()\n      .domain([d3.min(this.data, d => d.x) || 0, d3.max(this.data, d => d.x) || 0])\n      .range([leftMargin, this.width - this.margin.right]);\n    \n    // 使用D3的line生成器和曲线插值器\n    const line = d3.line<DataPoint>()\n      .x(d => adjustedXScale(d.x))\n      .y(d => this.yScale(d.y))\n      .curve(d3.curveCatmullRom.alpha(0.5)); // 使用CatmullRom曲线，alpha控制曲线张力\n    \n    // 获取路径数据\n    const pathData = line(animatedData);\n    \n    if (!pathData) return;\n    \n    // 绘制曲线\n    this.ctx.save();\n    this.ctx.beginPath();\n    \n    // 使用路径数据绘制\n    const path = new Path2D(pathData);\n    this.ctx.strokeStyle = this.getLineColor();\n    this.ctx.lineWidth = 2;\n    this.ctx.stroke(path);\n    \n    // 绘制阴影\n    if (this.getShowShadow()) {\n      this.ctx.beginPath();\n      \n      // 创建一个新的路径用于填充阴影区域\n      const areaPath = new Path2D(pathData);\n      \n      // 添加闭合区域的路径\n      areaPath.lineTo(adjustedXScale(animatedData[animatedData.length - 1].x), this.height - this.margin.bottom);\n      areaPath.lineTo(adjustedXScale(animatedData[0].x), this.height - this.margin.bottom);\n      areaPath.closePath();\n      \n      // 创建渐变\n      const gradient = this.ctx.createLinearGradient(0, this.margin.top, 0, this.height - this.margin.bottom);\n      const color = this.getLineColor();\n      gradient.addColorStop(0, `${color}80`); // 50% 透明度\n      gradient.addColorStop(1, `${color}00`); // 0% 透明度\n      \n      this.ctx.fillStyle = gradient;\n      this.ctx.fill(areaPath);\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 渲染关键点\n   */\n  private renderKeyPoints() {\n    // 过滤出在坐标范围内的关键点\n    const validKeyPoints = this.keyPoints.filter(point => {\n      const x = this.xScale(point.x);\n      const y = this.yScale(point.y);\n      \n      return (\n        x >= this.margin.left &&\n        x <= this.width - this.margin.right &&\n        y >= this.margin.top &&\n        y <= this.height - this.margin.bottom\n      );\n    });\n    \n    // 为每个关键点创建DOM元素\n    validKeyPoints.forEach(point => {\n      const keyPointElement = document.createElement('div');\n      keyPointElement.className = 'key-point';\n      \n      // 计算X轴位置\n      const xAxisY = this.height - this.margin.bottom;\n      \n      // 获取数据点的Y坐标\n      const pointY = this.yScale(point.y);\n      \n      // 创建临时元素来测量尺寸\n      const tempElement = document.createElement('div');\n      tempElement.className = 'key-point';\n      tempElement.innerHTML = point.render;\n      tempElement.style.position = 'absolute';\n      tempElement.style.visibility = 'hidden';\n      this.container.appendChild(tempElement);\n      \n      // 获取元素尺寸\n      const elementHeight = tempElement.offsetHeight;\n      const elementWidth = tempElement.offsetWidth;\n      \n      // 移除临时元素\n      this.container.removeChild(tempElement);\n      \n      // 计算关键点的X坐标\n      const pointX = this.xScale(point.x);\n      \n      // 获取Y轴的实际位置（动态计算）\n      // 获取Y轴刻度值\n      const yTicks = this.yScale.ticks(this.getTickCount());\n      \n      // 创建临时文本元素来测量文本宽度\n      const tempText = document.createElement('span');\n      tempText.style.visibility = 'hidden';\n      tempText.style.position = 'absolute';\n      tempText.style.fontSize = this.getAxisTextSize();\n      this.container.appendChild(tempText);\n      \n      // 获取文本宽度的函数\n      const getTextWidth = (text: string): number => {\n        tempText.textContent = text;\n        return tempText.offsetWidth;\n      };\n      \n      // 格式化刻度值并计算最大宽度\n      const formattedTicksMap = formatLargeNumber(yTicks);\n      const formattedValues = Object.values(formattedTicksMap);\n      const maxWidth = Math.max(...formattedValues.map(getTextWidth));\n      \n      // 计算Y轴的实际位置\n      const yAxisPosition = this.margin.left + maxWidth + 10;\n      \n      // 移除临时文本元素\n      this.container.removeChild(tempText);\n      \n      // 检查是否会超出右边界（考虑到transform: translateX(-50%)的影响，实际宽度是elementWidth/2）\n      const rightEdgePosition = pointX + elementWidth / 2;\n      const isExceedingRightBoundary = rightEdgePosition > (this.width - this.margin.right);\n      \n      // 检查是否会超出左边界（考虑到transform: translateX(-50%)的影响，实际宽度是elementWidth/2）\n      // 使用动态计算的Y轴位置，确保关键点不会绘制在Y轴之外\n      const leftEdgePosition = pointX - elementWidth / 2;\n      const isExceedingLeftBoundary = leftEdgePosition < yAxisPosition;\n      \n      // 调整X位置，确保不超出边界\n      let leftPosition = pointX;\n      if (isExceedingRightBoundary) {\n        // 将元素右对齐到右边界\n        leftPosition = this.width - this.margin.right - elementWidth / 2;\n      } else if (isExceedingLeftBoundary) {\n        // 将元素左对齐到Y轴位置，确保完全显示在Y轴右侧\n        leftPosition = yAxisPosition + elementWidth / 2;\n      }\n      \n      // 设置左侧位置\n      keyPointElement.style.left = `${leftPosition}px`;\n      \n      // 定义接近X轴的阈值（例如：距离X轴不到元素高度的2倍）\n      const proximityThreshold = elementHeight * 2;\n      \n      // 判断点是否靠近X轴\n      const isCloseToXAxis = (xAxisY - pointY) < proximityThreshold;\n      \n      // 计算top位置\n      let topPosition;\n\n      if (isCloseToXAxis) {\n        // 如果靠近X轴，将关键点显示在数据点上方\n        topPosition = pointY - elementHeight;\n        \n        // 确保不超出上边界\n        if (topPosition < this.margin.top) {\n          topPosition = this.margin.top;\n        }\n      } else {\n        // 如果不靠近X轴，保持在数据点位置\n        topPosition = pointY - 20;\n      }\n\n      // 设置top位置\n      keyPointElement.style.top = `${topPosition}px`;\n      \n      keyPointElement.innerHTML = point.render;\n      \n      this.container.appendChild(keyPointElement);\n    });\n  }\n  \n  /**\n   * 开始动画\n   */\n  private startAnimation() {\n    // 清除之前的动画\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n    \n    // 重置动画进度\n    this.animationProgress = 0;\n    \n    // 动画开始时间\n    const startTime = performance.now();\n    const duration = this.getAnimationDuration();\n    \n    // 动画函数\n    const animate = (currentTime: number) => {\n      // 计算动画进度\n      const elapsed = currentTime - startTime;\n      this.animationProgress = Math.min(elapsed / duration, 1);\n      \n      // 清除画布\n      if (this.ctx) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n      }\n      \n      // 绘制折线\n      this.drawLine(this.animationProgress);\n      \n      // 如果动画未完成，继续下一帧\n      if (this.animationProgress < 1) {\n        this.animationId = requestAnimationFrame(animate);\n      } else {\n        // 动画完成，渲染关键点\n        this.renderKeyPoints();\n        this.animationId = null;\n      }\n    };\n    \n    // 开始动画\n    this.animationId = requestAnimationFrame(animate);\n  }\n}\n\n// 注册Web Component\ncustomElements.define('d3-line-chart', D3LineChart);\n"],"names":["DEFAULT_CONFIG","lineColor","showShadow","gridColor","enableAnimation","animationDuration","axisTextColor","axisTextSize","curveType","tickCount","margin","top","right","bottom","left","perpendicularDistance","point","lineStart","lineEnd","x","Math","abs","slope","y","a","c","sqrt","b","rdpAlgorithm","points","epsilon","length","maxDistance","maxIndex","firstPoint","lastPoint","i","distance","leftPoints","slice","rightPoints","formatLargeNumber","yTicks","result","format","value","decimal","toFixed","toString","hasUniqueFormats","formattedValues","map","Set","size","forEach","D3LineChart","HTMLElement","constructor","super","this","ctx","data","keyPoints","keyTicks","config","width","height","xScale","d3","scaleLinear","yScale","animationProgress","animationId","shadow","attachShadow","mode","style","document","createElement","textContent","container","className","canvasContainer","getContext","svgContainer","createElementNS","appendChild","debouncedResize","fn","delay","timer","args","window","clearTimeout","setTimeout","apply","debounce","resize","bind","setupResizeObserver","connectedCallback","disconnectedCallback","cancelAnimationFrame","setConfig","undefined","render","getMargin","setEnableAnimation","enable","duration","setData","updateScales","setKeyPoints","setKeyTicks","getConfig","getEnableAnimation","getAnimationDuration","getGridColor","getLineColor","getShowShadow","getAxisTextColor","getAxisTextSize","getData","getKeyPoints","getKeyTicks","getCurveType","ResizeObserver","observe","rect","getBoundingClientRect","devicePixelRatio","scale","xExtent","extent","d","yExtent","domain","range","clearRect","firstChild","removeChild","querySelectorAll","el","remove","extendYScaleDomain","drawGridAndAxis","startAnimation","drawLine","renderKeyPoints","ticks","getTickCount","sort","dataMin","min","minTickDiff","extraTick","currentDomain","select","selectAll","g","formattedTicksMap","tempText","append","attr","Object","values","maxWidth","max","text","node","getBBox","newLeftMargin","enter","label","progress","drawCurveLine","drawLinearLine","xAxisLine","leftMargin","parseFloat","simplifiedData","dataLength","floor","animatedData","adjustedXScale","save","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","closePath","gradient","createLinearGradient","color","addColorStop","fillStyle","fill","restore","pathData","line","curve","curveCatmullRom","alpha","path","Path2D","areaPath","filter","keyPointElement","xAxisY","pointY","tempElement","innerHTML","position","visibility","elementHeight","offsetHeight","elementWidth","offsetWidth","pointX","fontSize","yAxisPosition","isExceedingLeftBoundary","leftPosition","topPosition","startTime","performance","now","animate","currentTime","elapsed","requestAnimationFrame","customElements","define"],"mappings":"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"}